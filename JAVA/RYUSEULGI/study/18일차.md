# 🤔 MainServer.java 50번째 줄(이해완료)

## 클라이언트들에게 결과를 전달하려고 while문을 선언할 때 <br> send 메소드와 cnt++만 해주면 된다고 생각했는데 <br> 다시 waitForClientRequest 메소드를 사용하는 이유는 무엇인가요?

### 데이터의 무결성 떄문 <br> 메모리를 정리하는 도중에 접근 하는 것을 방지하기 위해

```java
    while (cnt != 3) {
        System.out.println("사용자들에게 결과를 전달합니다.");
        ssm.waitForClientRequest();

        ssm.send(ssm.getClntSockArr(), ssm.getMaxClnt());

        cnt++;
    }
```

# 🤔 FirstThread.java(이해완료)

## 이미 사용한 t1스레드를 한 번 더 사용하니 t1과 t3가 출력되지 않는다. 이유는?

### 한 번 사용 된 스레드를 다시 사용 할 수 없기 때문

```java
    t1.start();
    t2.start();
    t3.start();
```

> 결과 <br>
> 고양이SCV가 미네랄을 채취했습니다. <br>
> 이름없음SCV가 미네랄을 채취했습니다.<br>
> 대머리독수리SCV가 미네랄을 채취했습니다.

```java
    t1.start();
    t2.start();
    t1.start();
    t3.start();
```

> 결과 <br>
> 이름없음SCV가 미네랄을 채취했습니다.<br>
> 대머리독수리SCV가 미네랄을 채취했습니다.

# DeadLock 교착상태

### 프로세스가 실행 할 때 필요한 자원이 존재 <br> 이 자원을 다른 프로세스가 사용중 일 때 프로세스는 대기 <br> 또 다른 프로세스도 이 자원을 사용하기 위해 대기를 할 때 교착상태가 발생

## 교착상태를 처리 하는 방법

1. 교착상태 방지 : 교착상태가 되는 필요조건을 불만족 시키기(현실적으로 불가능)
2. 교창상태 회피 : os에서 잘못 승인한 것으로 생각하게 만들기
3. 교착상태 검사 & 복구 : 교착상태가 일어나는 것을 허용하고 주기적으로 검사하는 방법, 비용적인 문제가 발생
4. 교착상태 무시

# Process & Thread

CPU는 한 순간에 한 가지 일 밖에 하지 못한다. <br>
그래서 프로세스들이 서로 사용해야 하는 시간이 정해져 있다. <br>
CPU가 실행하는 것이 프로세스! <br> 이런 프로세스들을 CPU가 돌려야 하는 코드라고 명시만 해주는 것(프로그램들이 동시에 작동된다고 생각하게 만든다)이 CPU의 추상화다.

<p align ="center"><img width="600" src="https://images.velog.io/images/s_keyyy/post/51645137-5751-48a8-9170-787028e9557b/File.jpg" alt="process_thread"></p>
<p align ="center">(+) stack도 스레드에 공유되는 정보</p>

-   1개의 프로세스가 가질 수 있는 스레드의 수가 정해져 있는 것은 아니지만 <br> 스레드가 실행될 때 메모리 공간이 필요하기 때문에 메모리의 크기 만큼 스레드를 가질 수 있다.
-   스레드 구현 방법 Runnable 인터페이스 사용하기
-   프로세스와 스레드의 차이점

    -   프로세스는 독립적이고 다른 프로세스에 영향을 주지 않는다
    -   스레드는 자원을 할당받아서 사용하고 스레드들끼리 연결이 되어 있다. <br> 그래서 1개의 스레드에 오류가 발생할 시 다른 스레드에도 영향을 줄 수 있다.
