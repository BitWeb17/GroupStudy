## Context Switching이란 무엇일까?
###우선 Context란 무엇일까 ?  
사전적 의미를 보자면 문맥이다.  
ex:  
A는 17살된 고등학생이다.  
B는 A의 아버지다.  
  
어느날 한밤 중 A는 몰컴을 하고 있었다.
A가 하던 게임은 실시간 게임이 아닌 FF같은 턴제 게임이었다.  
새벽 3시쯤 B의 방에서 문이 열리는 소리가 들렸고  
A는 그소리를 들었다.  
(B스레드가 A스레드의 제어권을 가져감)  

이때 A가 여러분이라면 어떤 행동을 취할 것인가?  
  
A는 B가 다가오는 것을 느끼고  
하던 게임을 멈추고 모니터를 끈 다음  
침대에 누워서 자는 척을 할 것이다.  
(B의 귀환을 유도 - 이벤트 핸들링)  

이후 B가 문을 열고 방안을 주시할 것이다.  
별 문제가 없다면 문을 닫고 돌아갈 것이며  
B의 귀환을 확인한 A는 다시 일어나서  
모니터를 키고 게임을 재개할 것이다.  
(이 때 게임에 pause를 걸었다면 게임을 이어서 할 수 있을 것임.)  

B가 다가오는 것: Interrupt(인터럽트), Event(이벤트)  
하던 게임을 멈추고 모니터를 끈 다음 침대에 누워서 자는 척:  
위 행위는 이벤트를 수신한 직후  
이 이벤트를 어떤식으로 다룰지에 대한 Handler(핸들러)에 해당한다.  

* Interrupt 혹은 Event가 발생하면  
현재 구동 중인 모든 작업을 중단하고  
  이 Event를 처리하러 간다. (최우선 과제임)  
  
B의 귀환: 이벤트 처리(핸들링)가 완료됨  
A가 다시 일어나서 모니터를 키고 게임을 재개함:  
멈춰놨던 작업을 다시 시작하는 형태  
  
문제는 내가 어디까지 했지????  
내가 현재 무엇을 어디까지 얼마나 했는지에 대한 정보: Context  
  

### Context Switching
(이번에는 변수 이름에 x를 붙여서 실제 하드웨어 레지스터임을 강조)  
(즉, 소프트 웨어를 활용하여 Mutex를 걸어 공유 변수의 공유를 막는 것과는 다른 개념!)  
(애초에 하드웨어는 공유를 하지 않으면 사용이 불가능하기 때문)  

```txt
1:  ax = 5               1:  ax = 4
2:  bx = ax + cx         2:  bx = ax * 2
3:  cx = 3               3:  cx = ax + bx
     
    Thread A                 Thread B
```
1) B가 1번까지 내용을 진행했다.
2) 그리고 제어권이 A로 넘어간다.
3) A도 1번까지 내용을 진행하고 제어권이 다시 B로 넘어간다.

Q) 그런데 어떻게 B가 다음에 2번을 실행하는지 아는걸까???  
A) 일단 다음에 실행할 명령은 ip 레지스터에 저장된다.  
 그리고 레지스터의 모든 내용을 보관하는 것이 Context였다.  
 결국 Context를 보고 어디를 해야하는지 알 수 있다.  
  
4) B가 이제 2번을 실행한다.  
이 경우 bx에는 올바른 값이 들어가는가? O  
   
결국 테스크가 생성될때마다 task_struct 안에  
Context를 저장할 수 있는 객체가 만들어진다.  
자기 자신의 Context를 자신이 관리하는 형식!  
  
지금 이 일련의 과정이 Context Switching이다.  
다른 스레드에게 제어권이 넘어가면 Context에 테스크 진행 상황을 저장해놓고  
다시 나에게 제어권이 넘어오면 Context를 다시 꺼내 처리한다.  
  
Context는 task_struct안에 있기 때문에 힙에 할당된다.  
그렇다는 것은 메모리영역에 잡힌다는 것이고  
그렇다는 것은 빈번한 Context Switching은 프로그램을 느리게 만든다.  
  
### Mutex vs Spinlock
``` java
spinlock pseudo code

for(;;) {
  while(lock) {
    doit!
  }
}
```

Q: 누가 더 좋을까?  
A: 그때 그때 다르다.  
  
Mutex 계열 동작 방식:  
다른 스레드가 접근했을때 Mutex 계열이 Lock을 흭득하고 있으면  
CPU가 알아서 다른 테스크에게 제어권을 넘긴다.  
(그 뜻은 ? Context Switching이 발생한다는 뜻)  
  
Spinlock이 Lock 동작 방식:  
다른 스레드가 접근했을 때 마찬가지로 Lcok을 흭득하고 있으면  
해당 작업이 끝날 때 까지 제어권을 쥐고 안놔준다.  
  
결론: 단순작업 - Spinlock 복잡한 작업 - Mutex  

Context Switching은  
모든 레지스터 정보, 태스크 정보, 메모리 관련 정보를 저장한다.  
(대충 봐도 저장할 분량이 많다는 것을 알 수 있다)  
수치적으로 비용을 계산해보는 것이다.  
대략 레지스터 -> 메모리로 가는 연산이  
10 clock 정도를 소요한다 가정한다.  
인텔은 레지스터가 14개니까  
대충 레지스터 옮기는 작업만 140 clock이 소요됨  
나머지가 추가로 소요를 하게 되는데  
모든 CPU의 특성상 레지스터 -> 레지스터 연산은 1 clock으로 처리된다.  
만약 처리하는 작업이 ax = bx + cx 같은 코드라면  
단순히 1 clock이 소요된다고 판정할 수 있다.  
