package SecondToFiveth;

public class BitOperation {
    public static void main(String[] args) {
        System.out.println("비트 연산자 예제입니다.");

        int num1 = 5;
        int num2 = 10;

        // &은 비트 연산자 AND를 의미함
        // AND 비트 연산자의 특징:
        // 같은 자리 수에 1이 배치된 경우에만 1이다.(비교 대상의 같은 자리 이진수가 모두 1인 경우에만 1이다.)
        // 그 외의 케이스는 모두 0이다.
        // 집합으로 보면 교집합
        int res = num1 & num2;
        System.out.println("num1 ANd num2 = " + res);

        // 숫자 10의 2진수 1010
        // 숫자 5의  2진수 0101
        //    10     1010
        //AND 5      0101
        //---------------
        //    0      0000

        // |는 비트 연산자 OR을 의미함
        // OR 비트 연산자의 특징:
        // 같은 자리 수에 하나라도 1이 배치되어 있다면 1이고 (비교 대상의 같은 자리 이진수가 둘중 하나라도 1인 경우에 1이다.)
        // 그렇지 않다면 0이 된다.
        // 집합으로 보자면 합집합
        res = num1 | num2;
        System.out.println("num1 OR num2 = " + res);

        // 숫자 10의 2진수 1010
        // 숫자 5의  2진수 0101
        //    10     1010
        //OR  5      0101
        //---------------
        //    15     1111

        // ^는 비트 연산자 XOR을 의미함
        // XOR 비트 연산자의 특징:
        // 서로 일치하는 것이 없는 경우에만 1이 된다. (비교 대상의 같은 자리 이진수가 일치하지 않으면 1이 된다.)
        res = num1 ^ num2;
        System.out.println("num1 XOR num2 = " + res);

        // 숫자 10의 2진수 1010
        // 숫자 5의  2진수 0101
        //    10     1010
        //XOR 5      0101
        //---------------
        //    15     1111

        // ~은 비트 연산자 NOT을 의미함
        // NOT 비트 연산자의 특징:
        // 모든 것을 부정한다.
        // 참의 부정 = 거짓
        // 거짓의 부정 = 참
        res = ~num1;
        System.out.println("NOT num1 = " + res);

        // 숫자 5의  2진수 0101
        //NOT 5    0000 0101
        //------------------
        //   -6    1111 1010
        
        // * 2진수 체계
        // Q: 왜 2진수를 알아야 하나?
        // A: 비트 연산자는 2진수를 기반으로 동작하기 때문
        
        // ex) 10진수의 경우에서 3421을 생각해보자
        // 10진수는 흔히 우리가 아는 숫자 체계 0 ~ 9 까지의 10개 숫자를 가지고 처리
        
        // n   3   2   1   0   --- 10^n 10의 n승 자리
        //     3   4   2   1   --- 10의 0승 자리에 1 10의 1승 자리에 2 10의 2승 자리에 4 10의 3승 자리에 3
        // 즉, 3 x 10^3 + 4 x 10^2 + 2 x 10^2 + 1 x 10^0 = 3421

        // ---------------------------------------------------------------
        // 핵심 개념: 2진수는 각 자리에 두 가지 숫자만 올 수 있다.
        // 2진수는 0 ~ 1 즉 두 개의 숫자만 올 수 있다.

        // ex) 2진수로 10진수 10을 표현해보자!

        //   n   3   2   1   0   --- 2^n 2의 n승 자리
        //       8   4   2   1   --- 계산된 2의 n승 자리
        //       1   0   1   0   --- 2^3가 1 2^2가 0 2^1이 1 2^0이 0
        // 즉, 2^3 x 1 + 2^2 x 0 + 2^1 x 1 + 2^0 x 0 = 8 + 2 = 10

        // * 10진수를 2진수로 만드는 가장 빠른 방법
        // 1. 변환하고자 하는 숫자를 선정한다. 예를 들어 23
        // 2. 변환하고자 하는 숫자보다 작지만 그 중 가장 큰 2의 n승을 선택한다.
        // 2^n = 1, 2, 4, 8, 16, 32, 64 .......
        // 현재 예시에선 23 보다 작지만 그 중 가장 큰 2의 n승은 16!
        // 16은 2의 4승
        // 3. 변환하고자 하는 숫자에서 2번에서 선택한 숫자를 뺀다.
        // 현재 예시에선 23 - 16 = 7!
        // 4. 나머지가 0이 될 때까지 2 ~ 3번을 반복한다.
        // 현재 예시에선 7을 선택하고 7보다 작지만 그 중 가장 큰 2의 n승인 4를 선택하고 뺀다.
        // 7 - 4 = 3이 된다.
        // 4는 2의 2승
        // 5. 3을 선택하고 근접한 3보다 작지만 그 중 가장 큰 2의 n승인 2를 선택하고 뺀다.
        // 3 - 2 = 1이 된다.
        // 2는 2의 1승이다.
        // 6. 1을 선택하고 근접한 2보다 작지만 그 중 가장 큰 2의n승인 1을 선택하고 뺀다.
        // 2 - 1 = 1이 된다.
        // 1은 2의 0승이다.

        // 10111(2) = 23

        // ---------------------------------------------------------------

        // * 2진수 표기 외울 것
        // 15 = 01111(2)
        // 16 = 10000(2)

        // 7 = 00111(2)
        // 8 = 01000(2)

        // 3 = 00011(2)
        // 4 = 00100(2)

        // 아스키코드 A = 65, a = 97  둘 사이 32차이
        //          B = 66, b = 66  둘 사이 32차이
        // 65 = 64 + 1
        // 0100 0001(2) = 65
        // 97 = 64 + 32 + 1

        //  0110 0001 = 97
        //  0010 0000 = 32 XOR
        //-------------------
        //  0100 0001 = 65

        //  0100 0001 = 65
        //  0010 0000 = 32 XOR
        // --------------------
        //  0110 0001 = 97

        // ---------------------------------------------------------------

        // * 컴퓨터에서 음수를 표현하는 방법
        // int는 정수형임을 모두 알고 있지만 음수 표현법은 좀 별개다.
        // int는 4바이트 정수형 데이터 타입
        // byte는 1바이트 데이터 타입
        // float은 4바이트 실수형 데이터 타입
        // double은 8바이트 실수형 데이터 타입

        // 바이트란?

        // 컴퓨터가 표현할 수 있는 최소 단위: 비트(bit)
        // 비트가 8개 모이면 바이트가 된다.
        // 그러므로 우리가 배웠던 int는 32비트가 된다.
        // 그래서 사실 비트 연산시 32개의 비트를 모두 적어 놓는 것이 정석이지만
        // 적을 것이 너무 많아지기 때문에 줄여서 8개 정도로 적어놓고 계산한다.

        // * NOT 연산자에 대한 추가 설명
        //   7    6    5    4    3    2    1    0    --- 2의 n승 자리
        //  128  64   32   16    8    4    2    1    --- 해당 자리에서의 숫자
        //   0    0    0    0    1    0    1    0    --- 숫자 5를 2진수로 표현
        // ---------------------------------------
        //   1    1    1    1    1    0    1    0    --- 이게 왜 -6일까?
        
        // 우선 int형은 맨 앞에 비트가 부호를 의미한다.
        // 맨 앞 비트가 0이면 양수, 1이면 음수이다.
        
        // 10진수에서의 6은 2진수로 110(2)이므로
        // 1000.............110(2) 이 -6일텐데 왜 위에처럼 나올까?
        
        // 위의 케이스가 안되는 이유는 0때문이다.
        // +1 + (-1) = 0
        // 0000 0001  = 1
        // 1000 0001  = -1 +
        //-----------------
        // 1000 0010  = 0??? 0이 아니다.
        
        // 음수 2진수가 나오는 과정
        //  1  1111 111  -- 올림 계산 2진수의 숫자는 0 ~ 1사이의 숫자로 처리
        //     0000 0001  = 1
        //     1111 1111  = -1 +
        //-----------------------
        //     0000 0000  = 0
        // 올림 계산을 하고 마지막으로 올린 숫자는 컴퓨터가 처리할 수 없는 숫자가 되어
        // 버려진 숫자가 되버린다.

        //  1  1111 11
        //     0000 0110  = 6
        //     1111 1010  = -6 +
        //-------------------------
        //     0000 0000  = 0

        // 어떤 숫자의 음수 2진수를 빠르게 구하는 알고리즘
        // 1. 먼저 만들고 싶은 음수의 양수 값을 2진수로 작성한다.
        // 2. 가장 낮은 자리에 있는 1을 찾는다.
        // 3. 해당 1을 찾은 자리까지의 값은 유지하고 나머지 값은 전부 반전한다.
        // (참(1) -> 거짓(0), 거짓(0) -> 참(1))

        // ---------------------------------------------------------------
    }
}
