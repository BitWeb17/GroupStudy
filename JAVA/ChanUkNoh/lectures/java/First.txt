2일차

public class BitOperation {
    public static void main(String[] args) {
        System.out.println("비트 연산자 예제입니다.");

        int num1 = 5;
        int num2 = 10;

        // &은 비트 연산자 AND를 의미함
        // AND 비트 연산자의 특징:
        // 같은 자리 수에 1이 배치된 경우에만 1이다.(비교 대상의 같은 자리 이진수가 모두 1인 경우에만 1이다.)
        // 그 외의 케이스는 모두 이다.
        // 집합으로 생각한다면 교집합
        int res = num1 & num2;
        System.out.println("num1 ANd num2 = " + res);

        // 숫자 10의 2진수 1010
        // 숫자 5의  2진수 0101
        //    10     1010
        //AND 5      0101
        //---------------
        //    0      0000

        // |는 비트 연산자 OR을 의미함
        // OR 비트 연산자의 특징:
        // 같은 자리 수에 하나라도 1이 배치되어 있다면 1이고 (비교 대상의 같은 자리 이진수가 둘중 하나라도 1인 경우에 1이다.)
        // 그렇지 않다면 0이 된다.
        // 집합으로 보자면 합집합
        res = num1 | num2;
        System.out.println("num1 OR num2 = " + res);

        // 숫자 10의 2진수 1010
        // 숫자 5의  2진수 0101
        //    10     1010
        //OR  5      0101
        //---------------
        //    15     1111

        // ^는 비트 연산자 XOR을 의미함
        // XOR 비트 연산자의 특징:
        // 서로 일치하는 것이 없는 경우에만 1이 된다. (비교 대상의 같은 자리 이진수가 일치하지 않으면 1이 된다.)
        res = num1 ^ num2;
        System.out.println("num1 XOR num2 = " + res);

        // 숫자 10의 2진수 1010
        // 숫자 5의  2진수 0101
        //    10     1010
        //XOR 5      0101
        //---------------
        //    15     1111

        // ~은 비트 연산자 NOT을 의미함
        // NOT 비트 연산자의 특징:
        // 모든 것을 부정한다.
        // 참의 부정 = 거짓
        // 거짓의 부정 = 참
        res = ~num1;
        System.out.println("NOT num1 = " + res);

        // 숫자 5의  2진수 0101
        //NOT 5    0000 0101
        //------------------
        //   -6    1111 1010
        
        // * 2진수 체계
        // Q: 왜 2진수를 알아야 하나?
        // A: 비트 연산자는 2진수를 기반으로 동작하기 때문
        
        // ex) 10진수의 경우에서 3421을 생각해보자
        // 10진수는 흔히 우리가 아는 숫자 체계 0 ~ 9 까지의 10개 숫자를 가지고 처리
        
        // n   3   2   1   0   --- 10^n 10의 n승 자리
        //     3   4   2   1   --- 10의 0승 자리에 1 10의 1승 자리에 2 10의 2승 자리에 4 10의 3승 자리에 3
        // 즉, 3 x 10^3 + 4 x 10^2 + 2 x 10^2 + 1 x 10^0 = 3421

        // ---------------------------------------------------------------
        // 핵심 개념: 2진수는 각 자리에 두 가지 숫자만 올 수 있다.
        // 2진수는 0 ~ 1 즉 두 개의 숫자만 올 수 있다.

        // ex) 2진수로 10진수 10을 표현해보자!

        //   n   3   2   1   0   --- 2^n 2의 n승 자리
        //       8   4   2   1   --- 계산된 2의 n승 자리
        //       1   0   1   0   --- 2^3가 1 2^2가 0 2^1이 1 2^0이 0
        // 즉, 2^3 x 1 + 2^2 x 0 + 2^1 x 1 + 2^0 x 0 = 8 + 2 = 10

        // * 10진수를 2진수로 만드는 가장 빠른 방법
        // 1. 변환하고자 하는 숫자를 선정한다. 예를 들어 23
        // 2. 변환하고자 하는 숫자보다 작지만 그 중 가장 큰 2의 n승을 선택한다.
        // 2^n = 1, 2, 4, 8, 16, 32, 64 .......
        // 현재 예시에선 23 보다 작지만 그 중 가장 큰 2의 n승은 16!
        // 16은 2의 4승
        // 3. 변환하고자 하는 숫자에서 2번에서 선택한 숫자를 뺀다.
        // 현재 예시에선 23 - 16 = 7!
        // 4. 나머지가 0이 될 때까지 2 ~ 3번을 반복한다.
        // 현재 예시에선 7을 선택하고 7보다 작지만 그 중 가장 큰 2의 n승인 4를 선택하고 뺀다.
        // 7 - 4 = 3이 된다.
        // 4는 2의 2승
        // 5. 3을 선택하고 근접한 3보다 작지만 그 중 가장 큰 2의 n승인 2를 선택하고 뺀다.
        // 3 - 2 = 1이 된다.
        // 2는 2의 1승이다.
        // 6. 1을 선택하고 근접한 2보다 작지만 그 중 가장 큰 2의n승인 1을 선택하고 뺀다.
        // 2 - 1 = 1이 된다.
        // 1은 2의 0승이다.

        // 10111(2) = 23

        // ---------------------------------------------------------------

        // * 2진수 표기 외울 것
        // 15 = 01111(2)
        // 16 = 10000(2)

        // 7 = 00111(2)
        // 8 = 01000(2)

        // 3 = 00011(2)
        // 4 = 00100(2)

        // 아스키코드 A = 65, a = 97  둘 사이 32차이
        //          B = 66, b = 66  둘 사이 32차이
        // 65 = 64 + 1
        // 0100 0001(2) = 65
        // 97 = 64 + 32 + 1

        //  0110 0001 = 97
        //  0010 0000 = 32 XOR
        //-------------------
        //  0100 0001 = 65

        //  0100 0001 = 65
        //  0010 0000 = 32 XOR
        // --------------------
        //  0110 0001 = 97

        // ---------------------------------------------------------------

        // * 컴퓨터에서 음수를 표현하는 방법
        // int는 정수형임을 모두 알고 있지만 음수 표현법은 좀 별개다.
        // int는 4바이트 정수형 데이터 타입
        // byte는 1바이트 데이터 타입
        // float은 4바이트 실수형 데이터 타입
        // double은 8바이트 실수형 데이터 타입

        // 바이트란?

        // 컴퓨터가 표현할 수 있는 최소 단위: 비트(bit)
        // 비트가 8개 모이면 바이트가 된다.
        // 그러므로 우리가 배웠던 int는 32비트가 된다.
        // 그래서 사실 비트 연산시 32개의 비트를 모두 적어 놓는 것이 정석이지만
        // 적을 것이 너무 많아지기 때문에 줄여서 8개 정도로 적어놓고 계산한다.

        // * NOT 연산자에 대한 추가 설명
        //   7    6    5    4    3    2    1    0    --- 2의 n승 자리
        //  128  64   32   16    8    4    2    1    --- 해당 자리에서의 숫자
        //   0    0    0    0    1    0    1    0    --- 숫자 5를 2진수로 표현
        // ---------------------------------------
        //   1    1    1    1    1    0    1    0    --- 이게 왜 -6일까?
        
        // 우선 int형은 맨 앞에 비트가 부호를 의미한다.
        // 맨 앞 비트가 0이면 양수, 1이면 음수이다.
        
        // 10진수에서의 6은 2진수로 110(2)이므로
        // 1000.............110(2) 이 -6일텐데 왜 위에처럼 나올까?
        
        // 위의 케이스가 안되는 이유는 0때문이다.
        // +1 + (-1) = 0
        // 0000 0001  = 1
        // 1000 0001  = -1 +
        //-----------------
        // 1000 0010  = 0??? 0이 아니다.
        
        // 음수 2진수가 나오는 과정
        //  1  1111 111  -- 올림 계산 2진수의 숫자는 0 ~ 1사이의 숫자로 처리
        //     0000 0001  = 1
        //     1111 1111  = -1 +
        //-----------------------
        //     0000 0000  = 0
        // 올림 계산을 하고 마지막으로 올린 숫자는 컴퓨터가 처리할 수 없는 숫자가 되어
        // 버려진 숫자가 되버린다.

        //  1  1111 11
        //     0000 0110  = 6
        //     1111 1010  = -6 +
        //-------------------------
        //     0000 0000  = 0

        // 어떤 숫자의 음수 2진수를 빠르게 구하는 알고리즘
        // 1. 먼저 만들고 싶은 음수의 양수 값을 2진수로 작성한다.
        // 2. 가장 낮은 자리에 있는 1을 찾는다.
        // 3. 해당 1을 찾은 자리까지의 값은 유지하고 나머지 값은 전부 반전한다.
        // (참(1) -> 거짓(0), 거짓(0) -> 참(1))

        // ---------------------------------------------------------------
    }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------

import java.util.Scanner;

public class IfBasedRangeProblem {
    public static void main(String[] args) {
        
        // * SwitchCaseStatement 클래스의 switch예제를 if문으로 작성할 경우
        
        Scanner scan = new Scanner(System.in);

        System.out.println("점수를 입력하세요");
        int num = scan.nextInt();

        System.out.println("입력한 점수는 " + num);

        // 주의점: if-else if 사용시 히든 조건을 매우 조심해야한다.
        // 잘못 작성할 경우 프로그램 논리가 통채로 잘못될 가능성이 있고
        // 디버깅을 통해 오류를 잡는 것이 오래 걸릴 가능성이 높다.

        // 팁: 가장 범주가 큰 녀석을 위로 올리고
        // 그것보다 작은 범주의 크기조건을 서서히 단계단계 내리며 작성한다.

        if(num > 100) { // num이 100 보다 크다면
            System.out.println("잘못된 입력입니다.");
        } else if(num >= 90) {  // num이 90 이상이라면 && 100 보다 작거나 같다면  | 가장 큰 범위부터
            System.out.println("당신의 등급은 A입니다.");  //                   |
        } else if(num >= 80) {  // num이 80 이상이라면 && 90 보다 작다면         |
            System.out.println("당신의 등급은 B입니다.");
        } else if(num >= 70) {  // num이 70 이상이라면 && 80 보다 작다면         |
            System.out.println("당신의 등급은 C입니다.");
        } else if(num >= 60) {  // num이 60 이상이라면 && 70 보다 작다면         |
            System.out.println("당신의 등급은 D입니다.");
        } else if(num >= 0) {   // num이 0 이상이라면 && 60 보다 작다면          |
            System.out.println("빵야 빵야 F"); //                             V 가장 작은 범위로 작성해야 오류가 안남
        } else {    // 0 보다 작다면
            System.out.println("잘못된 입력입니다.");
        }
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------


import java.util.Scanner;

public class IfTest {
    // psvm - IntelliJ의 main메서드 생성 단축키
    public static void main(String[] args) {
        // sout - IntelliJ의 System.out.println(); 단축키
        System.out.println();

        String str1 = "짝수";
        String str2 = "홀수";

        Scanner scan = new Scanner(System.in);
        System.out.println("숫자를 입력하세요");
        int num = scan.nextInt();

        // 문자열과 숫자가 + 되면 자동으로 숫자는 문자열이 되어서 처리된다.
        System.out.println("당신이 입력한 숫자는 = " + num);
        System.out.println("당신이 입력한 숫자는 = " + num + num);

        // 실제로 숫자를 처리하고자 한다면
        // 연산의 순서를 아래와 같이 변경하여 작업하면 된다.
        System.out.println("당신이 입력한 숫자는 = " + (num + num));

        //-------------------------------------------------------

        // 3항 연산자를 작성하는 방법
        // 먼저 3항 연산자는 아래와 같은 형식으로 구성된다.
        // (condition) ? true인 경우 반환 값 : false인 경우 반환 값;

        // 아래 케이스의 경우엔 조건에 따라 결과 값이 바뀌는데
        // 이 값을 res라는 변수에 대입한 것
        String res = (num % 2 == 0) ? str1 : str2;

        System.out.println(num + "은 " + res + "입니다!");

    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------

import java.util.Scanner;

public class LogicalOperation {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.println("숫자를 입력하세요");
        int num = scan.nextInt();

        // && 논리 연산자 AND
        // 논리 연산자 AND는 두 개의 조건이 모두 참인 경우에만 참이다.

        if((num % 2 == 0) && (num % 3 == 0)) {
            // 2의 배수이면서 3의 배수인가? = 6의 배수인가?
            // 두 조건이 모두 참이면 본문을 실행한다.
            System.out.println(num + "은 6의 배수다!");
        } else {
            System.out.println(num + "은 6의 배수가 아니다!");
        }

        // || 논리 연산자 OR
        // 둘 중 하나라도 참이라면 참
        if((num % 2 == 0) || (num % 3 == 0)) {
            System.out.println(num + "은 2혹은 3의 배수다!");
        } else {
            System.out.println(num + "은 2혹은 3의 배수가 아니다!");
        }

        // ! 논리 연산자 NOT
        // 결과 자체를 부정한다.
        if(!(num % 2 == 0)) {
            System.out.println(num + "은 2의 배수가 아니다!");
        } else {
            System.out.println((num + "은 2의 배수다!"));
        }
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------

public class PrefixSuffixOperation {
    public static void main(String[] args) {
        int num = 3;

        System.out.println("전위 연산자" + ++num);
        System.out.println("전위 연산자" + ++num);
        System.out.println("결과: " + num);

        num = 3;

        System.out.println("후위 연산자" + num++);
        System.out.println("후위 연산자" + num++);
        System.out.println("결과: " + num);
    }
}

================================================================================

import java.util.Scanner;

public class SecondProbTest {
    // * if문을 작성하는 방법
    // 1. if를 적고 소괄호를 열고 닫고 중괄호를 열고 닫는다. if(condition) {body...}
    // 2. 소괄호 내부에 조건을 작성한다. (해당 조건이 만족되면 중괄호의 내용을 수행한다.)
    // 3. 중괄호 내부에 구동시킬 코드를 작성한다.


    public static void main(String[] args) {
        // 변수란?
        // 1. 값을 받는 것
        // 엄밀한 정의: 특정한 데이터타입을 저장할 수 있는 메모리 공간
        // 너프한 정의: 특정한 데이터타입을 저장할 수 있는 공간

        // 입력받은 숫자가 2의 배수인지 판별해보자!
        // 아래 보이는 Scanner scan = new Scanner(system.in)
        // 이 전체가 scan이라는 변수를 통해서 키보드 입력을 받을 것임을 알려주는 것
        Scanner scan = new Scanner(System.in);
        // new Scanner(System.in) 을 통해 실제 키보드 정보를 흭득
        System.out.println("숫자를 입력하세요");

        // 키보드 입력에 대한 처리는 아래 코드에서 수행합니다.
        // '='은 ~~와 같다가 아닌 할당, 대입 연산임을 명시하자!!
        int num = scan.nextInt(); // 실제 키보드 입력을 처리한는 부분

        System.out.println("입력 결과는 = " + num);

        // --------------------------------------------------
        // num % 2
        // % 연산자는 나머지를 구하는 연산자다.
        // num % 2는 'num을 2로 나누고 그 나머지를 구하라' 라는 뜻이다.
        // 어떤 수를 2로 나눈 나머지는 0 혹은 1 뿐이다.
        // 나머지가 0이라는 뜻은 2로 나눠 떨어진다는 뜻이며
        // 2로 나눠 떨어진다면 이 값은 짝수임을 알 수 있다.
        // 나머지가 0이 아니라 1이면 홀수 일 것이다.
//        -------------------------------------------------
        // '==' 은 앞에 것과 뒤의 것이 같은지 질문을 하는 것이다.
        // 질문에 답이 맞다면 true(1), 아니면 false(0)
        if(num % 2 == 0) { // num을 2로 나눈 나머지가 0이 맞나요? 만약 맞으면 본문을 실행해주세요.
            System.out.println("짝수입니다.");
        } else { // else는 if의 조건이 맞지 않은경우 실행한다.
            System.out.println("홀수입니다.");
        }
    }
}

================================================================================

public class ShiftOperator {
    public static void main(String[] args) {
        System.out.println("쉬프트 연산자 예제");

        // final 이란 무엇인가? 값을 고정시키는 역할을 수행한다.
        // 그런데 왜 값을 고정할까?
        // 매직 넘버
        // 공장에는 생산라인이 5개 있다.
        // 사업을 따내서 생산라인이 8개가 되었다.
        // 결국 유지 보수를 편하게 하기 위해 사용한다.

        final int SCALE_FACTOR1 = 2;
        final int SCALE_FACTOR2 = 3;
        final int SCALE_FACTOR3 = 1;
        int num = 10, num2 = 5;

        // 쉬프트 연산도 2진수와 연결이 된다.
        // 숫자 10 - 0000 1010을 왼쪽 쉬프트로 2칸 이동한다.
        // 결과 40 - 0010 1000이 된다.
        System.out.println("10 << 2 = " + (num << SCALE_FACTOR1));
        // 2칸 올라올때 빈 공간은 0으로 채워지고
        // 넘치는 공간은 버린다.
        // 3칸 이동
        // 결과 80 - 0101 0000이 된다.
        // 쉬프트 한 칸당 2의 n승이 곱해지는 것을 볼 수 있다.
        System.out.println("10 << 3 = " + (num << SCALE_FACTOR2));
        // 숫자 5 - 0000 0101 이며 오른쪽으로 1칸 이동한다.
        // 결과 2 - 0000 0010 이 된다.
        // 우리가 예상한 것은 2.5이지만 실제로 2가 나왔다.
        // 이유는 쉬프트 연산이 정수에서만 가능하기 때문이다.
        // 주의점: 곱셈은 2의n을 곱하면 되지만 나눗셈의 경우엔 나머지를 버리고 몫만 취한다.
        System.out.println("5 << 1 = " + (num2 >> SCALE_FACTOR3));

        // 쉬프트에 의해 데이터가 사라지는 것을 확인할 수 있는 예
        // 원래는 5 << 1과 같기 때문에 10이 나와야 하지만
        // 먼저 계산된 괄호속의 쉬프트 연산에서 데이터가 사라져서 88이 나오는 것을 확인할 수 있다.
        System.out.println("(5 >> 1) << 2 = " +
                ((num2 >> SCALE_FACTOR3) << SCALE_FACTOR1));
    }
}

================================================================================


import java.util.Scanner;

public class SwitchCaseStatement {
    public static void main(String[] args) {
        // * switch문 장석 방법
        // 1. switch를 적고 소괄호를 열고 닫고 중괄호를 열고 닫는다.
        // 2. 소괄호 내부에 조건(케이스가 될 숫자 등등)을 작성한다.
        // 3. 중괄호 내부에는 각각의 케이스를 'case:'형태로 작성한다.
        // 4. 각각의 케이스에서 동작할 코드를 작성하고 break한다.
        // 5. 필요하다면 break를 빼고 묶을 수도 있다.

        // Q: switch문은 언제 사용하나요?
        // A: 케이스가 명확한 경우에 세세한 조작을 수행하기 위해 사용한다.

        // Q: switch문에서 default의 용도는 무엇인가요?
        // A: case각각의 케이스들을 적는다고 하였는데 해당하는 케이스가 하나도 없을 경우 default가 동작한다.

        System.out.println("switch 문을 배워 봅시다!");

        Scanner scan = new Scanner(System.in);

        System.out.println("점수를 입력하세요: ");
        int num = scan.nextInt();

        if((num > 100) || (num < 0)) {
            System.out.println("잘못된 값을 입력하였습니다.");
        }

        // (int)(num / 10.0f)
        // 위의 코드는 결과를 강제로 int형으로 처리하는 방식이다.
        // 10.0f라는 것이 보이는데 실수형에 f가 오면 float 타입을 의미한다.
        // 결국 f를 쓰지 않으면 double 타입을 의미한다.
        // 위의 방식을 강제 캐스팅 Type Casting이라 부른다.
        int fnum = (int)(num / 10.0f);
        System.out.println("실수형을 정수형으로 만든 값 = " + fnum);

        // 90 ~ 100: A, 80 ~ 89: B, 70 ~ 79: C, 60 ~ 69: D, 나머지 F
        // 90 ~ 100 / 10 = 9.0 ~ 10.0
        // 80 ~ 89 / 10 = 8.0 ~ 8.9
        // 70 ~ 79 / 10 = 7.0 ~ 7.9
        // 60 ~ 69 / 10 = 6.0 ~ 6.9
        // 0 ~ 59 / 10 = 0.0 ~ 5.9

        // break가 case마다 있는 것을 볼 수 있다.
        // break가 없는 경우 아래와 같이 case10과 case9인 경우엔
        // 10과 9에 대해 모두 같은 처리를 하겠음을 의미한다.
        // 즉, break를 만나기 전까지는 동작이 유지된다.
        switch (fnum) {
            case 10:
            case 9:
                System.out.println("당신의 등급은 A");
                break;
            case 8:
                System.out.println("당신의 등급은 B");
                break;

            case 7:
                System.out.println("당신의 등급은 C");
                break;
            case 6:
                System.out.println("당신의 등급은 D");
                break;
            default:
                System.out.println("총 맞았습니다 F 빵야! 빵야!");
                break;
        }
    }
}


================================================================================

import java.util.Scanner;

public class Work3 {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.println("숫자 입력해주세요");
        int anyNum = scan.nextInt();

        System.out.println(anyNum);

        System.out.println("입력 값은 : " + anyNum);

        if (anyNum % 5 == 1) {
            System.out.println("나머지1");
        } else {
            System.out.println("아님");
        }
    }
}

================================================================================


import java.util.Scanner;

public class Work3 {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.println("숫자 입력해주세요");
        int anyNum = scan.nextInt();

        System.out.println(anyNum);

        System.out.println("입력 값은 : " + anyNum);

        if (anyNum % 5 == 1) {
            System.out.println("나머지1");
        } else {


            System.out.println("아님");
        }
    }
}


================================================================================

import java.util.Scanner;

public class Work6 {
    public static void main(String[] args) {

//        1500이 입력되면 정지하는 시스템이 있다.
//                입력값은 1000 ~ 2000 사이의 숫자다.
//        (아직 랜덤을 배우지 않았으므로 키보드 입력으로 처리한다)
//        1470 이하의 값을 넣으면 후진
//        1530 이상의 값을 넣으면 전진한다.
//        이를 if 문과 Scanner를 통해 구현해보자!

        Scanner scan = new Scanner(System.in);

        System.out.println("제어 pwm을 입력하세요");
        int pwm = scan.nextInt();

        System.out.println("당신이 입력한 pwm 값: " + pwm);

        if (pwm > 2000) {
            System.out.println("wrong number");
        } else if(pwm > 1529) {
            System.out.println("전진");
        } else if(pwm > 1470) {
            System.out.println("정지");
        } else if(pwm > 999) {
            System.out.println("후진");
        } else {
            System.out.println("wrong number");
        }
    }
}

