import java.util.Scanner;

public class Exercise5 {
    public static void main(String[] args) {
        System.out.println("2의 n승을 판정해보자!");

        Scanner scan = new Scanner(System.in);
        System.out.print("아무런 숫자나 입력해보세요: ");

        int num = scan.nextInt();
        System.out.println("입력값은 = " + num);

//      2의 n승이란?
//      0000 0001     1
//      0000 0010     2
//      >>>>>>>>>>>>>>>
//      0000 0011     3
//      0000 0100     4
//      >>>>>>>>>>>>>>>
//      0000 0101     5
//      >>>>>>>>>>>>>>>
//      0000 0110     6
//      0000 1000     8
//      0001 0000     16
//      0010 0000     32
//      0100 0000     64

        if (num == 0) {
            System.out.println("0 입니다.");
        }

//      Q: 조건식에 괄호가 없으면 왜 오류인가?
//      A: 아래 코드를 보면 빨간줄이 나오는데 빨간 줄에 커서를 갖다 대면
//      required type: boolean provided type: int
//      라는 차이가 보일 것이다. 컴퓨터가 요구하는 타입은
//      boolean(논리형)인데 사용자가 작성하여 제공한 타입이
//      int 형이기 때문에 오류!

//      case B의 경우엔 '==' 같은가요? 라는 질문이다.
//      이 질문에 대한 답은 yes(true) 혹은 no(false) 뿐이다.

//      boolean은 참 혹은 거짓을 표현하는 데이터 타입이다.

//      case C의 경우엔 에러 메시지가 아래와 같다.
//      Operatior '&' cannot be applied to 'in', ' boolean'
//      비트 연산자 AND는 int와 boolean간에 적용이 불가능하다.
//      산술 비트 연산은 정수형 변수 혹은 상수(3, 5 등등) 끼리 가능하다.
//      연산자 우선순위가 & 보다 == 이 높아서 이런 현상이 발생함

//      Q: case A의 괄호는 조건이 아닌가요?
//      단순히 산술 연산식 입니다.
//      조건이 되려면 case B나 C처럼 질문을 해야함
//      그러면 질문의 대한 답이 false(거짓) 혹은 true(참)으로 나옴

//      case A: if(num & (num - 1))
//      case B: if( (num & (num-1)) == 0 )
//      case B: if(num & (num-1) == 0 )

        // Q: 2이 n승을 판정하는 알고리즘이 이해가 안갑니다.
        // A: 일단은 2의 n승이 가지는 특성을 살펴봐야 한다.
        //    대표적인 특성이 2의 n승과 2의 n승 - 1 의 특성임

        // 15 = 01111(2): 2^4 - 1
        // 16 = 10000(2): 2^4
        //
        // 7 = 00111(2): 2^3 - 1
        // 8 = 01000(2): 2^3
        //
        // 3 = 00011(2): 2^2 - 1
        // 4 = 00100(2): 2^2

        // 2진수 특성상 2의 n승에서 1을 빼면
        // 해당 자리수가 0 이되고 나머지 아래의 자리값은 모두 최대값이 된다.

        // 10000 - 1
        //  9999

        // 16 8 4 2 1
        //  1 0 0 0 0 (2) - 00001(2)
        //  0 1 1 1 1 (2)   AND: 같은 자리수에 서로 값이 참(1)인 경우에만 참(1)
        // ------------------
        //  0 0 0 0 0 (2)

        //  0 1 1 1 1 (2)
        //  0 1 0 0 0 (2)

        //  2의 n승과 2의 n승 - 1의 AND는 어떤 상황에서든지 0을 만들게 된다.

        // Q: 2^n + 1을 XOR로 하면 안될까요 ?
        // A: 아래와 같이 기준(결과값 31, 15 등등)이 모호하게 됩니다.

        //  0 1 1 1 1 (2):  15
        //  1 0 0 0 0 (2):  16   XOR
        // -------------------------
        //  1 1 1 1 1    :  31

        //  0 1 1 1 (2):  7
        //  1 0 0 0 (2):  8   XOR
        // -------------------------
        //  1 1 1 1    :  15

        // Q: (num ^ (num + 1)) == (num + (num + 1))는 안될까요 ?
        // A: (num & (num - 1)) == 0 위의 케이스와 현재 케이스의 비교시
        //    연산량이 위의 케이스가 더 많습니다.
        //    프로그램 최적화 차원에서
        //    위의 케이스보다 아래의 케이스가 조금 더 효율적입니다.
        //    문제를 풀 수는 있습니다 - 속도가 조금 떨어질뿐
        // Err: + 1 로 할 경우 입력값이 2^n - 1이어야 참이됨
        // Sol: (num ^ (num - 1)) == (num + (num - 1))
        //      위의 형식으로 해야 입력값을 2^n일 때 참
        //      아래 boolean 코드는 증명
        boolean res = (num ^ (num - 1)) == (num + (num - 1));
        System.out.println("res = " + res);

        // int res = num & (num - 1);

        if( (num & (num-1)) == 0 ) {
            System.out.println("입력숫자 " + num + "은 2의 n승 입니다.");
        } else {
            System.out.println("입력숫자 " + num + "은 2의 n승이 아닙니다.");
        }
    }
}
